import tl = require('azure-pipelines-task-lib/task');
import {IssueType} from "azure-pipelines-task-lib";
import {downloadFile, getSecrets, getValue, KeeperFile, loadJsonConfig} from "@keeper-security/secrets-manager-core";
import * as fs from "fs";

/*
    Azure Pipeline:
    - Pipeline Variable: variable that can be referenced in other places inside the pipeline.

    - Output Variable: is a specific kind of pipeline variable that is created by a task.
                       The deployment task assigns a value to a variable which then makes
                       it available to use across a pipeline. Output variables essentially are
                       pipeline variables. They are created by the pipeline and are referenced by
                       other tasks in the pipeline. The big difference is how they are created.

                       Unlike a general pipeline variable, an output variable is defined and value
                       generated by the output of a task. Output variables are dynamic and represent
                       the result of a particular task. They are not statically defined as above.
                       You will never know an output variableâ€™s value until a task in the pipeline
                       runs.

 */
enum DestinationType {
    output,
    environment,
    file,
    variable
}

type SecretsInput = {
    notation: string
    destination: string
    destinationType: DestinationType
}

export const parseSecretsInputs = (inputs: string[]): SecretsInput[] => {
    const results: SecretsInput[] = []

    for (const input of inputs) {
        const inputParts = input.replace(/\s/g, '').split('>')
        let destinationType: DestinationType = DestinationType.output
        let destination = inputParts[1]

        if (destination.startsWith('out:')) {
            destinationType = DestinationType.output
            destination = destination.slice(4)
        } else if (destination.startsWith('var:')){
            destinationType = DestinationType.variable
            destination = destination.slice(4)
        } else if (destination.startsWith('file:')) {
            destinationType = DestinationType.file
            destination = destination.slice(5)
        }

        if (inputParts[0].split('/')[1] === 'file') {
            destinationType = DestinationType.file
        }

        results.push({
            notation: inputParts[0],
            destination,
            destinationType
        })
    }
    return results
}

export const getRecordUids = (inputs: SecretsInput[]): string[] => {
    const set = new Set<string>()
    for (const input of inputs) {
        set.add(input.notation.split('/')[0])
    }
    return Array.from(set)
}

const downloadSecretFile = async (file: KeeperFile, destination: string): Promise<void> => {
    const fileData = await downloadFile(file)
    fs.writeFileSync(destination, fileData)
}

async function run() {

    try {
        const config: string | undefined = tl.getInput('keepersecretconfig', true)
        const secrets_input_arr = tl.getDelimitedInput('secrets', '\n', true)

        if (config == null) {
            tl.setResult(tl.TaskResult.Failed, 'config was empty')
            return
        }

        // @ts-ignore
        const inputs = parseSecretsInputs(secrets_input_arr)
        const uids_to_retrieve = getRecordUids(inputs)
        const secrets = await getSecrets({storage: loadJsonConfig(config)}, uids_to_retrieve).
                                catch(reason => {
                                    tl.logIssue(IssueType.Error, reason.stack)
                                    tl.setResult(tl.TaskResult.Failed, reason.message)
                                    return
                                })

        tl.debug("secrets_input_arr: [" + JSON.stringify(secrets_input_arr) + "]")
        tl.debug("inputs: [" + JSON.stringify(inputs) + "]")
        tl.debug("uids_to_retrieve: [" + JSON.stringify(uids_to_retrieve) + "]")

        for (const input of inputs) {

            // @ts-ignore
            const secret = await getValue(secrets, input.notation)

            if(typeof secret === 'string') {
                tl.debug("Masking secret for notation: " + input.notation)
                tl.setSecret(secret)
            } else {
                tl.debug("Not Masking secret for notation: " + input.notation + " (type: " + typeof secret + ")")
            }

            tl.debug("input: [" + JSON.stringify(input) + "]")

            // Azure docs on how to pass variables:
            //  https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&tabs=yaml%2Cbatch

            switch (input.destinationType) {
                case DestinationType.variable:
                    tl.setVariable(input.destination, secret, true, false)
                    //
                    // Example to retrieve variable
                    //   steps:
                    //   - script: echo $(foo)
                    //     name: echovar
                    //
                    // See: https://stackoverflow.com/a/56518088/51230

                    break
                case DestinationType.output:
                    tl.setVariable(input.destination, secret, true, true)
                    // access:
                    //      $(foo) or in the form of [originating_task name]_[variable name]
                    //
                    //  In a task within that same job, you can reference that variable using $(SomeTask.out).
                    //
                    //      steps:
                    //      - task: MyTask@1
                    //        name: SomeTask
                    //      - script: echo $(SomeTask.out)
                    //
                    //  See: https://www.nigelfrank.com/blog/azure-devops-output-variables/
                    break
                case DestinationType.file:

                    await downloadSecretFile(secret as KeeperFile, input.destination)
                    tl.debug(`Finish downloading file to ${input.destination}`)

                    // xtlguWgodbpFkKJn7_7mAQ/file/rose2.jpeg > file:/tmp/rose2.jpeg

                    break
            }
        }

    } catch (error) {
        if (error != null)
            { // @ts-ignore
                tl.setResult(tl.TaskResult.Failed, error.message);
            }
    }
}

run().then((result) => {
        tl.setResult(tl.TaskResult.Succeeded, "");
    })
    .catch((error) => {
    tl.setResult(tl.TaskResult.Failed, error);
});
