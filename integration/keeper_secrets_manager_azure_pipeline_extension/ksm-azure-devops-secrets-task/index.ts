import * as tl from "azure-pipelines-task-lib/task"
import {IssueType} from "azure-pipelines-task-lib"
import {
    downloadFile,
    getSecrets,
    getValue,
    KeeperFile,
    loadJsonConfig,
    parseNotation
} from "@keeper-security/secrets-manager-core"
import * as fs from "fs"

/**
 * Polyfill for Array.prototype.at() method
 *
 * Why this is needed:
 * 1. The Array.prototype.at() method was introduced in ES2022 but is not available in all JavaScript environments.
 * 2. Specifically, as of September 2024, Azure Pipelines' default Node.js version does not support this method.
 * 3. It provides a convenient way to access array elements, especially with negative indices (e.g., arr.at(-1) for the last element).
 * 4. This polyfill ensures consistent behavior across different environments, including Azure Pipelines.
 *
 * How it works:
 * 1. We first declare the 'at' method in the global Array interface for TypeScript type safety.
 * 2. We then check if the method already exists to avoid overwriting native implementations.
 * 3. If not present, we implement the method, handling both positive and negative indices.
 *
 * Note: This polyfill should be reviewed periodically and removed once Azure Pipelines updates its
 * default Node.js version to one that includes native support for Array.prototype.at() (Node.js 16.6.0 and later).
 * Keep an eye on Azure Pipelines documentation for updates on supported Node.js versions.
 */

// Declare the 'at' method in the global Array interface for TypeScript
declare global {
    interface Array<T> {
        at(index: number): T | undefined;
    }
}

// Only add the polyfill if the method doesn't already exist
if (!Array.prototype.at) {
    tl.debug("Array.prototype.at() is not supported in this environment. Adding polyfill.");
    Array.prototype.at = function<T>(this: T[], index: number): T | undefined {
        // Convert the index to an integer
        const n = Math.trunc(index) || 0;

        // Handle negative indices by counting from the end of the array
        if (n < 0) return this[this.length + n];

        // Return the element at the calculated index
        return this[n];
    };
} else {
    tl.debug("Array.prototype.at() is natively supported in this environment.");
}

/*
    Azure Pipeline:
    - Pipeline Variable: variable that can be referenced in other places inside the pipeline.

    - Output Variable: is a specific kind of pipeline variable that is created by a task.
                       The deployment task assigns a value to a variable which then makes
                       it available to use across a pipeline. Output variables essentially are
                       pipeline variables. They are created by the pipeline and are referenced by
                       other tasks in the pipeline. The big difference is how they are created.

                       Unlike a general pipeline variable, an output variable is defined and value
                       generated by the output of a task. Output variables are dynamic and represent
                       the result of a particular task. They are not statically defined as above.
                       You will never know an output variable's value until a task in the pipeline
                       runs.

 */
enum DestinationType {
    output,
    environment,
    file,
    variable
}

type SecretsInput = {
    notation: string
    parsedNotation: any[]
    destination: string
    destinationType: DestinationType
}

export const parseSecretsInputs = (inputs: string[]): SecretsInput[] => {
    const results: SecretsInput[] = []

    for (const input of inputs) {
        const pos = input.lastIndexOf('>')
        if (pos < 0) {
            tl.debug("Error parsing input '" + input + "' - Skipped (expected format: notation > destination)")
            continue
        }

        const inputParts = [input.slice(0, pos), input.slice(pos + 1)]
        const parsedNotation = parseNotation(inputParts[0])
        const notation = inputParts[0].trim()

        let destinationType: DestinationType = DestinationType.output
        let destination = inputParts[1].trim()
        if (destination.startsWith('out:')) {
            destinationType = DestinationType.output
            destination = destination.slice(4)
        } else if (destination.startsWith('var:')){
            destinationType = DestinationType.variable
            destination = destination.slice(4)
        } else if (destination.startsWith('file:')) {
            destinationType = DestinationType.file
            destination = destination.slice(5)
        }

        if (parsedNotation[2]?.text && parsedNotation[2].text[0] === 'file') {
            destinationType = DestinationType.file
        }

        results.push({
            notation: notation,
            parsedNotation: parsedNotation,
            destination,
            destinationType
        })
    }
    return results
}

export const getRecordUids = (inputs: SecretsInput[]): string[] => {
    const set = new Set<string>()
    for (const input of inputs) {
        set.add(input.notation.split('/')[0])
    }
    return Array.from(set)
}

export const getRecordFilter = (inputs: SecretsInput[]): string[] => {
    const rids: Set<string> = new Set(inputs.map(item => item.parsedNotation[1].text[0]));
    const records = Array.from(rids)
    // if non UID detected (search by title) return empty list
    const hasTitles: boolean = records.some(item => ! item.match(/^[A-Za-z0-9_-]{22}$/))
    const uidFilter: string[] = hasTitles ? [] : records
    return uidFilter
}

const downloadSecretFile = async (file: KeeperFile, destination: string): Promise<void> => {
    const fileData = await downloadFile(file)
    fs.writeFileSync(destination, fileData)
}

async function run() {
    try {
        const config: string | undefined = tl.getInput('keepersecretconfig', true)
        const secrets_input_arr = tl.getDelimitedInput('secrets', '\n', true)

        if (config == null) {
            tl.setResult(tl.TaskResult.Failed, 'config was empty')
            return
        }

        // @ts-ignore
        const inputs = parseSecretsInputs(secrets_input_arr)
        let uids_to_retrieve = getRecordFilter(inputs)
        let secrets = await getSecrets({storage: loadJsonConfig(config)}, uids_to_retrieve).
                                catch(reason => {
                                    tl.logIssue(IssueType.Error, reason.stack)
                                    tl.setResult(tl.TaskResult.Failed, reason.message)
                                    return
                                })
        // there's a slight chance a valid title to match a recordUID (22 url-safe base64 chars)
        // or a missing record or record not shared to the KSM App - we need to pull all records
        if (uids_to_retrieve.length > 0 && (!secrets || secrets.records.length < uids_to_retrieve.length)) {
            tl.debug("KSM didn't get expected number of records - requesting all (search by title or missing UID /not shared to the app/)")
            uids_to_retrieve = []
            secrets = await getSecrets({storage: loadJsonConfig(config)}, uids_to_retrieve).
            catch(reason => {
                tl.logIssue(IssueType.Error, reason.stack)
                tl.setResult(tl.TaskResult.Failed, reason.message)
                return
            })
        }

        tl.debug("secrets_input_arr: [" + JSON.stringify(secrets_input_arr) + "]")
        tl.debug("inputs: [" + JSON.stringify(inputs) + "]")
        tl.debug("uids_to_retrieve: [" + JSON.stringify(uids_to_retrieve) + "]")

        for (const input of inputs) {
            // @ts-ignore
            const secret = await getValue(secrets, input.notation)

            if(typeof secret === 'string') {
                tl.debug("Masking secret for notation: " + input.notation)
                tl.setSecret(secret)
            } else {
                tl.debug("Not Masking secret for notation: " + input.notation + " (type: " + typeof secret + ")")
            }

            tl.debug("input: [" + JSON.stringify(input) + "]")

            // Azure docs on how to pass variables:
            //  https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables?view=azure-devops&tabs=yaml%2Cbatch

            switch (input.destinationType) {
                case DestinationType.variable:
                    tl.setVariable(input.destination, secret, true, false)
                    //
                    // Example to retrieve variable
                    //   steps:
                    //   - script: echo $(foo)
                    //     name: echovar
                    //
                    // See: https://stackoverflow.com/a/56518088/51230
                    break
                case DestinationType.output:
                    tl.setVariable(input.destination, secret, true, true)
                    // access:
                    //      $(foo) or in the form of [originating_task name]_[variable name]
                    //
                    //  In a task within that same job, you can reference that variable using $(SomeTask.out).
                    //
                    //      steps:
                    //      - task: MyTask@1
                    //        name: SomeTask
                    //      - script: echo $(SomeTask.out)
                    //
                    //  See: https://www.nigelfrank.com/blog/azure-devops-output-variables/
                    break
                case DestinationType.file:
                    await downloadSecretFile(secret as KeeperFile, input.destination)
                    tl.debug(`Finish downloading file to ${input.destination}`)
                    break
            }
        }
    } catch (error) {
        // @ts-ignore
        tl.setResult(tl.TaskResult.Failed, error?.message ?? "unknown error")
    }
}

run().then((result) => {
        tl.setResult(tl.TaskResult.Succeeded, "")
    })
    .catch((error) => {
    tl.setResult(tl.TaskResult.Failed, error)
})
